## 第一节 地址空间



地址空间是内核与应用进程的生存活动空间。内核或应用要运行，就首先需要被加载到指定地址的一段内存中，以指令流的形式存在；CPU 的指令寄存器 **PC** 将从入口指令的地址开始执行，过程中需要不断的跳转，读写特定地址的内存数据，访问指定地址的IO端口等等。地址是内核与应用管理自身和环境资源的主要标识。我们需要在内核或应用（进程）投入运行之前，为它们可能涉及的各种资源的初始地址和占用范围进行统一的安排，这种安排就是地址空间。

我们目前开发的内核是 **Unikernel** 形态，关于地址空间：

* 从特权级的角度，不存在用户态进程空间（Unikernel 甚至连进程概念都没有），内核与应用共用内核态的**单一**地址空间。当内核启动时，它所面对的就是一个由硬件平台决定的**物理**地址空间。
* 基于**分页**机制，我们可以在上述物理地址空间的基础上，再新增一个**虚拟**地址空间，以获得更好的地址管理的灵活性。



<div style="text-align:center">
   <img src=".\img\物理与虚拟地址空间.svg" alt="物理与虚拟地址空间" style="zoom:100%"/>
</div>



CPU 有一个附属部件 MMU（Memory Management Unit），它的主要作用就是控制分页机制的启用。MMU 默认是未启用分页的，所以内核启动时，直接看到的就是物理地址空间，并通过资源的物理地址来访问它们，我们目前就正处在这个状态；然后内核按照需要规划虚拟地址空间的布局，并定义为页表，在适当的时候通过设置 MMU 去启用分页，此时虚拟地址空间开始出现并发挥作用，遮蔽了物理地址空间；此后，内核只能看到并访问虚拟地址空间，所以必须使用资源的虚拟地址，分页机制负责对虚拟地址进行映射，一部分会被实际映射到物理空间的某些地址上，而另一部分可能暂时或者永远处于**未**映射的状态。

可以看出，物理地址空间是硬件平台生产构造时就已经确定的，而虚拟地址空间则是内核可以根据实际需要，进行灵活定义和实时改变的。按照近年来流行的说法，分页机制也可以称为“软件定义”地址空间。

以下就针对我们的实验平台 qemu-riscv64-virt，进行分析和实验。



### 物理地址空间

物理地址空间由硬件平台在生产时决定，通常以 FDT（flattened device tree）的形式提供。对于 qemu-riscv64-virt 平台，我们可以通过如下方式导出它的 fdt 文件。

首先运行`make run`，在屏幕输出中可以看到 qemu 的执行命令行：

<div style="text-align:center">
   <img src=".\img\qemu执行命令行.png" alt="qemu执行命令行" style="zoom:100%"/>
</div>

注意上图中显示的是 qemu-system-riscv64 执行时的命令行，修改这行命令，在参数 *"-machine virt"* 后面追加 *",dumpdtb=virt.dtb"*。如此，我们就改变了这行命令的执行效果，不再是启动模拟器，而是导出名为 **virt.dtb** 的 fdt 文件，然后就退出了。此时，我们得到的还只是二进制格式的 fdt 文件，进一步用 dtc 工具，把它转换成可读的文本形式。

```shell
# 在参数"-machine virt"之后, 增加 ",dumpdtb=virt.dtb"，用于导出fdt文件的二进制格式dtb
qemu-system-riscv64 -m 128M -smp 1 -machine virt,dumpdtb=virt.dtb \
	-bios default -kernel target/riscv64gc-unknown-none-elf/release/axorigin.bin -nographic

# 把二进制形式virt.dtb，转化为可读的文本形式
dtc ./virt.dtb -o ./virt.dts
```

> <font size=2>注意：执行上面的命令行导出 fdt 时，一定要保留所有参数。qemu 是根据参数来决定 fdt 中一些配置项的具体内容。例如，参数指定了`-m 128M`，则 qemu 就会模拟 128M 的物理内存，相应的 fdt 中描述的 memory 就是 128M。</font>

现在查看 **virt.dts** 的内容，仅节选与下步实验密切相关的部分：

```json
/dts-v1/;

/ {
    #address-cells = <0x02>;
    #size-cells = <0x02>;
    compatible = "riscv-virtio";
    model = "riscv-virtio,qemu";
	... ...
    memory@80000000 {
        device_type = "memory";
        reg = <0x00 0x80000000 0x00 0x8000000>;
    };
    ... ...
    soc {
        #address-cells = <0x02>;
        #size-cells = <0x02>;
        compatible = "simple-bus";
        ranges;
  		... ...
        serial@10000000 {
            interrupts = <0x0a>;
            interrupt-parent = <0x03>;
            clock-frequency = "\08@";
            reg = <0x00 0x10000000 0x00 0x100>;
            compatible = "ns16550a";
        };
		... ...
        virtio_mmio@10001000 {
            interrupts = <0x01>;
            interrupt-parent = <0x03>;
            reg = <0x00 0x10001000 0x00 0x1000>;
            compatible = "virtio,mmio";
        };
        ... ...
    };
};
```

现在先跳过 fdt 的其它细节，注意 *memory*、*serial* 和 *virtio_mmio* 这几项的 *reg* 字段，该字段是一个包含四个值的序列，描述了对应设备所占用地址空间的开始地址和长度。字段 #address-cells 和 #size-cells 都是 2，说明前两个值解析为范围的开始地址，后两个值对应范围长度。另外，注意 fdt 采用大端序。这样我们就知道了物理内存从 **0x8000_0000** 地址开始，长度是 0x800_0000 即 128M，发现确实是与命令行参数对应的；而串口 serial 从 0x1000_0000 开始，长度 256 字节；第一个 virtio_mmio slot 的地址从 0x1000_1000 开始，长度是 4096 字节，后面按顺序排列了另外七个 virtio_mmio slot。现在可以画出我们实验平台大致的物理地址空间布局了：

<div style="text-align:center">
   <img src=".\img\物理地址空间布局.svg" alt="物理地址空间布局" style="zoom:150%"/>
</div>



在第零章，我们提到需要把 SBI 放到物理内存开始的位置 **0x8000_0000** 地址处，这里就解释了该地址是如何得知的。此外，通过 fdt，我们还知道了 qemu 实验平台上，各个设备所占用的 mmio 范围，它们集中在物理空间的低地址范围内。其中 virtio mmio slots 是后面实验中发现与操作 virtio 设备的基础信息，我们将在后续章节再分析它们。本章暂时只关注内存管理，先完成内存部分——即 0x8000_0000 之后的虚拟地址空间映射。

> <font size=2>从第一章我们知道，内核最早启动时，a1 寄存器保存的就是 fdt 二进制数据块 dtb 的开始指针。这个数据块与我们在本节中导出分析的 fdt 内容完全相同。fdt 是内核获取硬件平台配置信息的主要途径。目前为止，我们只是人工查看导出的 fdt 信息，并应用到内核的开发实验中。到下一章的最后一节，我们将通过实验让内核自动解析 fdt 来获取这些关键信息。</font>



### 虚拟地址空间

本章我们建立的虚拟地址空间只需要与物理空间形成简单的**线性映射**，并且只处理包含 SBI 和 Kernel 存储区的 1G 范围。如下图，虚拟地址范围 0xFFFF_FFC0_8000_0000 ~ 0xFFFF_FFC0_C000_0000 线性映射到物理地址范围0x8000_0000 ~ 0xC000_0000。

<div style="text-align:center">
   <img src=".\img\虚拟到物理空间映射.svg" alt="虚拟到物理空间映射" style="zoom:100%"/>
</div>


线性偏移的好处是，只需要通过加减偏移运算，内核就能够在虚拟地址与物理地址间进行转换，我们把这个线性偏移的常量称为 **PHYS_VIRT_OFFSET**，相应的运算公式表示为：

```js
VA = PA + PHYS_VIRT_OFFSET;
PA = VA - PHYS_VIRT_OFFSET;
```

当前实验中 PHYS_VIRT_OFFSET = 0xFFFF_FFC0_0000_0000，与我们选择的分页机制方案 Sv39 有关。我们开发的内核是 64 位系统，原本最大可用的地址空间范围是 64 位；但是按照 Riscv 规范，Sv39 有效的虚拟地址范围被约束为最大 39 位，从 40 位往上那些未使用的位必须与第 39 位一致。也就是说，如果第 39 位是 1，从第 40 位向上全部填充 1，有效范围 0xFFFF_FFC0_0000_0000 ~ 0xFFFF_FFFF_FFFF_FFFF；如果第 39 位是 0，高位全部填充 0，那么有效地址范围就是从 0 到 0x3F_FFFF_FFFF 。这两个范围处于 64 位空间最高端和最低端这两头的位置。按照惯例，我们选择了高端的这个范围，把它作为内核本身的虚拟地址空间；低端的那个范围暂时预留，将来支持宏内核模式时，我们把它作为应用进程的虚拟地址空间。

下一节开始基于 Sv39 方案，建立我们内核的分页机制。



<script src="https://utteranc.es/client.js"
        repo="OSLearning365/blog-issues"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
